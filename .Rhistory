#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k = 0.005, k.ratio = 1,
Ci.lim, C0.lim) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- -k
kappa.min <- k.max*k.ratio
# kappa.start <- -k
} else {
kappa.max <- k.max*k.ratio
kappa.min <- k
# kappa.start <- k
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
# lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
# upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
lower = c(Ci=0, C0=0, k=kappa.min),
#upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
View(CO2_results)
View(CO2_results)
#'               Same units as Ci.
#' @param C0.lim numerical vector of length 2; inferior and superior limits of
#'               the intercept (initial concentration). Same units as C0.
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k = 0.005, k.ratio = 1,
Ci.lim, C0.lim) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- -k
kappa.min <- k.max*k.ratio
# kappa.start <- -k
} else {
kappa.max <- k.max*k.ratio
kappa.min <- k
# kappa.start <- k
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
# lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
# upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
# lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
View(CO2_results)
#'               Same units as Ci.
#' @param C0.lim numerical vector of length 2; inferior and superior limits of
#'               the intercept (initial concentration). Same units as C0.
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k = 0.005, k.ratio = 1,
Ci.lim, C0.lim) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
View(CO2_results)
#'               Same units as Ci.
#' @param C0.lim numerical vector of length 2; inferior and superior limits of
#'               the intercept (initial concentration). Same units as C0.
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k.ratio = 1) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
kappa.min
#' @seealso [k.max()]
#'
#' @examples
#' data(example_LGR_manID)
#' goFlux(example_LGR_manID, "CO2dry_ppm")
#' goFlux(example_LGR_manID, "CH4dry_ppb")
#' goFlux(example_LGR_manID, "H2O_ppm")
#'
#' @export
#'
goFlux <- function(dataframe, gastype, H2O_col = "H2O_ppm", prec = NULL,
Area = NULL, offset = NULL, Vtot = NULL, Vcham = NULL,
Pcham = NULL, Tcham = NULL, k.ratio = 1, Ci.lim = NULL,
C0.lim = NULL) {
# Assign NULL to variables without binding
H2O_ppm <- H2O_mol <- Etime <- flag <- NULL
# Modify global options for warning: break for-loop after warning message
options(warn = 2)
# Use provided values for Area, offset, Vcham, Vtot, Pcham and Tcham
# if they are missing from dataframe
if (!is.null(Area)) {
dataframe <- dataframe %>% mutate(Area = Area)
}
if (!is.null(offset)) {
dataframe <- dataframe %>% mutate(offset = offset)
}
if (!is.null(Vcham)) {
dataframe <- dataframe %>% mutate(Vcham = Vcham)
}
if (!is.null(Vtot)) {
dataframe <- dataframe %>% mutate(Vtot = Vtot)
}
if (!is.null(Pcham)) {
dataframe <- dataframe %>% mutate(Pcham = Pcham)
}
if ((!is.null(Tcham))) {
dataframe <- dataframe %>% mutate(Tcham = Tcham)
}
# Calculate Vtot if absent from dataframe
if (!any(grepl("Vtot", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Vtot = Vcham + (Area * offset))
}
# Use normal atmospheric pressure and ambient temperature
# if Pcham and Tcham are missing from dataframe
if (!any(grepl("Pcham", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Pcham = 101.325)
}
if (!any(grepl("Tcham", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Tcham = 15)
}
# Clean and subset data (per gastype)
if (gastype != "H2O_ppm") {
data_split <- dataframe %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Use mutate() to convert H2O_ppm into H2O_mol
mutate(H2O_mol = H2O_ppm / (1000*1000)) %>%
select(UniqueID, H2O_mol, Etime, Vtot, Pcham, Area, Tcham,
flag, matches(gastype)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
} else
if (gastype == "H2O_ppm") {
data_split <- dataframe %>%
select(UniqueID, Etime, Vtot, Pcham, Area, Tcham,
flag, all_of(H2O_col)) %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
}
# Instrument precision (by gastype)
# If prec = NULL, the default parameters are set to the LI-7810 for CH4 and CO2,
# or the LI-7820 for N2O. Both instruments have the same precision for H2O.
if (is.null(prec)) {
prec <- ifelse(gastype == "CO2dry_ppm", 3.5,
ifelse(gastype == "CH4dry_ppb", 0.6,
ifelse(gastype == "N2Odry_ppb", 0.4,
ifelse(gastype == "H2O_ppm", 45, NA))))
} else { prec = prec }
# Calculate auxiliary variables: flux term and minimal detectable flux
for (f in 1:length(data_split)) {
H2O_flux.term <- ifelse(gastype == "H2O_ppm", 0, first(data_split[[f]]$H2O_mol))
data_split[[f]] <- data_split[[f]] %>%
mutate(flux.term = flux.term(first(Vtot), first(Pcham), first(Area),
first(Tcham), H2O_flux.term),
f.min = MDF(prec, (max(Etime)+1), n(), flux.term))
}
# Create an empty list to store results
flux.res.ls <- list()
# Print a progress bar
pb = txtProgressBar(min = 0, max = length(data_split), initial = 0, style = 3)
# Flux calculation
for (f in 1:length(data_split)) {
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
# C.diff <- abs(Ci-C0)
# if (is.null(Ci.lim)) {
#   Ci.limits <- c(Ci-C.diff*0.2, Ci+C.diff*0.2)
# } else {Ci.limits = Ci.lim}
# if (is.null(C0.lim)) {
#   C0.limits <- c(C0-C.diff*0.2, C0+C.diff*0.2)
# } else {C0.limits = C0.lim}
# Calculate kappa thresholds based on MDF, LM.flux and Etime
# kappa.min <- 1 / (max(data_split[[f]]$Etime)+1)
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
# Hutchinson and Mosier
HM.res <- HM.flux(gas.meas = gas.meas, time.meas = data_split[[f]]$Etime,
flux.term = flux.term, Ci = Ci, C0 = C0,
k.max = kappa.max)
# Flux results and G factor
flux.res.ls[[f]] <- cbind.data.frame(
UniqueID, LM.res, HM.res, f.min, flux.term, k.max = kappa.max,
g.fact = g.factor(HM.res$HM.flux, LM.res$LM.flux))
# Update progress bar
setTxtProgressBar(pb, f)
}
# Unlist flux results
flux_results <- map_df(flux.res.ls,  ~as.data.frame(.x))
# Close progress bar
close(pb)
# Modify global options for warning: set option back to default
options(warn = 0)
# Return results
return(flux_results)
}
#'               Same units as Ci.
#' @param C0.lim numerical vector of length 2; inferior and superior limits of
#'               the intercept (initial concentration). Same units as C0.
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k.ratio = 1) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
View(CO2_results)
