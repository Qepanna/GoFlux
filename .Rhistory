rename(H2O_ppm = all_of(H2O_col)) %>%
# Use mutate() to convert H2O_ppm into H2O_mol
mutate(H2O_mol = H2O_ppm / (1000*1000)) %>%
select(UniqueID, H2O_mol, Etime, Vtot, Pcham, Area, Tcham,
flag, matches(gastype)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
} else
if (gastype == "H2O_ppm") {
data_split <- dataframe %>%
select(UniqueID, Etime, Vtot, Pcham, Area, Tcham,
flag, all_of(H2O_col)) %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
}
# TEST
library(dplyr)
# Clean and subset data (per gastype)
if (gastype != "H2O_ppm") {
data_split <- dataframe %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Use mutate() to convert H2O_ppm into H2O_mol
mutate(H2O_mol = H2O_ppm / (1000*1000)) %>%
select(UniqueID, H2O_mol, Etime, Vtot, Pcham, Area, Tcham,
flag, matches(gastype)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
} else
if (gastype == "H2O_ppm") {
data_split <- dataframe %>%
select(UniqueID, Etime, Vtot, Pcham, Area, Tcham,
flag, all_of(H2O_col)) %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
}
library(tidyr)
# Clean and subset data (per gastype)
if (gastype != "H2O_ppm") {
data_split <- dataframe %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Use mutate() to convert H2O_ppm into H2O_mol
mutate(H2O_mol = H2O_ppm / (1000*1000)) %>%
select(UniqueID, H2O_mol, Etime, Vtot, Pcham, Area, Tcham,
flag, matches(gastype)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
} else
if (gastype == "H2O_ppm") {
data_split <- dataframe %>%
select(UniqueID, Etime, Vtot, Pcham, Area, Tcham,
flag, all_of(H2O_col)) %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
}
# Instrument precision (by gastype)
# If prec = NULL, the default parameters are set to the LI-7810 for CH4 and CO2,
# or the LI-7820 for N2O. Both instruments have the same precision for H2O.
if (is.null(prec)) {
prec <- ifelse(gastype == "CO2dry_ppm", 3.5,
ifelse(gastype == "CH4dry_ppb", 0.6,
ifelse(gastype == "N2Odry_ppb", 0.4,
ifelse(gastype == "H2O_ppm", 45, NA))))
} else { prec = prec }
# Calculate auxiliary variables: flux term and minimal detectable flux
for (f in 1:length(data_split)) {
H2O_flux.term <- ifelse(gastype == "H2O_ppm", 0, first(data_split[[f]]$H2O_mol))
data_split[[f]] <- data_split[[f]] %>%
mutate(flux.term = flux.term(first(Vtot), first(Pcham), first(Area),
first(Tcham), H2O_flux.term),
f.min = MDF(prec, (max(Etime)+1), n(), flux.term))
}
#' @param V_L numerical; total volume inside the chamber, tubes, instruments, etc. (L)
#' @param P_kPa numerical; atmospheric pressure (kPa)
#' @param A_cm2 numerical; area of the soil surface inside the chamber (cm2)
#' @param T_C numerical; air temperature before chamber closure (Celsius)
#' @param H2O_mol numerical; water vapor concentration in the air before chamber closure (mol/mol)
#'
#' @return a numerical value
#'
#' @keywords internal
#'
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
#' @param gas.meas numerical vector containing gas measurements (ppm or ppb)
#' @param time.meas numerical vector containing time stamps (seconds)
#' @param flux.term numerical value; flux term calculated with the function flux.term
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
#' flux estimate and the measurement time. The units of the kappa-max is s-1
#'
#' @param MDF numerical; minimal detectable flux, calculated with the function MDF
#' @param LM.flux numerical; flux estimate from a linear flux calculation model
#' @param t measurement time (enclosure time) (seconds)
#'
#' @return a numerical value
#'
#' @keywords internal
#'
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
#'
#' @param HM.flux a numerical value; flux estimate from a non-linear flux
#'                calculation model (e.g. Hutchinson and Mosier; HM)
#' @param LM.flux a numerical value; flux estimate from a linear flux
#'                calculation model
#'
#' @return a numerical value
#'
#' @keywords internal
#'
g.factor <- function(HM.flux, LM.flux){
HM.flux/LM.flux
}
#'
#' @param p numerical; precision of the instrument (same units as measured gas; ex. ppm)
#' @param t numerical; measurement time (enclosure time; seconds)
#' @param n numerical; number of measurements during measurement time
#' @param flux.term numerical; flux term calculated with the function flux.term
#'
#' @return a numerical value
#'
#' @keywords internal
#'
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
# Calculate auxiliary variables: flux term and minimal detectable flux
for (f in 1:length(data_split)) {
H2O_flux.term <- ifelse(gastype == "H2O_ppm", 0, first(data_split[[f]]$H2O_mol))
data_split[[f]] <- data_split[[f]] %>%
mutate(flux.term = flux.term(first(Vtot), first(Pcham), first(Area),
first(Tcham), H2O_flux.term),
f.min = MDF(prec, (max(Etime)+1), n(), flux.term))
}
# Create an empty list to store results
flux.res.ls <- list()
# Print a progress bar
pb = txtProgressBar(min = 0, max = length(data_split), initial = 0, style = 3)
# Flux calculation
for (f in 1:length(data_split)) {
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
C.diff <- abs(Ci-C0)
if (is.null(Ci.lim)) {
Ci.limits <- c(Ci-C.diff*0.2, Ci+C.diff*0.2)
} else {Ci.limits = Ci.lim}
if (is.null(C0.lim)) {
C0.limits <- c(C0-C.diff*0.2, C0+C.diff*0.2)
} else {C0.limits = C0.lim}
# Calculate kappa thresholds based on MDF, LM.flux and Etime
kappa.min <- 1 / (max(data_split[[f]]$Etime)+1)
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
# Hutchinson and Mosier
HM.res <- HM.flux(gas.meas = gas.meas, time.meas = data_split[[f]]$Etime,
flux.term = flux.term, Ci = Ci, C0 = C0, k = kappa.min,
k.max = kappa.max, Ci.lim = Ci.limits, C0.lim = C0.limits)
# Flux results and G factor
flux.res.ls[[f]] <- cbind.data.frame(
UniqueID, LM.res, HM.res, f.min, flux.term, k.max = kappa.max,
g.fact = g.factor(HM.res$HM.flux, LM.res$LM.flux))
# Update progress bar
setTxtProgressBar(pb, f)
}
library(msm)
library(minpack.lm)
# Flux calculation
for (f in 1:length(data_split)) {
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
C.diff <- abs(Ci-C0)
if (is.null(Ci.lim)) {
Ci.limits <- c(Ci-C.diff*0.2, Ci+C.diff*0.2)
} else {Ci.limits = Ci.lim}
if (is.null(C0.lim)) {
C0.limits <- c(C0-C.diff*0.2, C0+C.diff*0.2)
} else {C0.limits = C0.lim}
# Calculate kappa thresholds based on MDF, LM.flux and Etime
kappa.min <- 1 / (max(data_split[[f]]$Etime)+1)
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
# Hutchinson and Mosier
HM.res <- HM.flux(gas.meas = gas.meas, time.meas = data_split[[f]]$Etime,
flux.term = flux.term, Ci = Ci, C0 = C0, k = kappa.min,
k.max = kappa.max, Ci.lim = Ci.limits, C0.lim = C0.limits)
# Flux results and G factor
flux.res.ls[[f]] <- cbind.data.frame(
UniqueID, LM.res, HM.res, f.min, flux.term, k.max = kappa.max,
g.fact = g.factor(HM.res$HM.flux, LM.res$LM.flux))
# Update progress bar
setTxtProgressBar(pb, f)
}
# Unlist flux results
flux_results <- map_df(flux.res.ls,  ~as.data.frame(.x))
# Close progress bar
close(pb)
library(purrr)
# Unlist flux results
flux_results <- map_df(flux.res.ls,  ~as.data.frame(.x))
View(flux_results)
f = 1
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
C.diff <- abs(Ci-C0)
if (is.null(Ci.lim)) {
Ci.limits <- c(Ci-C.diff*0.2, Ci+C.diff*0.2)
} else {Ci.limits = Ci.lim}
if (is.null(C0.lim)) {
C0.limits <- c(C0-C.diff*0.2, C0+C.diff*0.2)
} else {C0.limits = C0.lim}
# Calculate kappa thresholds based on MDF, LM.flux and Etime
kappa.min <- 1 / (max(data_split[[f]]$Etime)+1)
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
# Hutchinson and Mosier
HM.res <- HM.flux(gas.meas = gas.meas, time.meas = data_split[[f]]$Etime,
flux.term = flux.term, Ci = Ci, C0 = C0, k = kappa.min,
k.max = kappa.max, Ci.lim = Ci.limits, C0.lim = C0.limits)
View(HM.res)
gas.meas = gas.meas
time.meas = data_split[[f]]$Etime
k = kappa.min
C0.lim = C0.limits
Ci.lim = Ci.limits
k.max = kappa.max
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- -k
kappa.min <- k.max
} else {
kappa.max <- k.max
kappa.min <- k
}
# adjust kappa.max with k.ratio
kappa.max <- kappa.max*k.ratio
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
if (k.max < 0) {
start <- list(Ci=Ci, C0=C0, k=kappa.max)
} else {
start <- list(Ci=Ci, C0=C0, k=kappa.min)
}
start
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
HM <- try(nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
inherits(HM, "try-error")
#'               Same units as Ci.
#' @param C0.lim numerical vector of length 2; inferior and superior limits of
#'               the intercept (initial concentration). Same units as C0.
#'
#' @return a data.frame
#'
#' @include GoFluxYourself-package.R
#'
#' @keywords internal
#'
HM.flux <- function(gas.meas, time.meas, flux.term, k.max,
Ci = NULL, C0 = NULL, k = 0.005, k.ratio = 1,
Ci.lim = NULL, C0.lim = NULL) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- -k
kappa.min <- k.max
} else {
kappa.max <- k.max
kappa.min <- k
}
# adjust kappa.max with k.ratio
kappa.max <- kappa.max*k.ratio
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
if (k.max < 0) {
start <- list(Ci=Ci, C0=C0, k=kappa.max)
} else {
start <- list(Ci=Ci, C0=C0, k=kappa.min)
}
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!inherits(HM, "try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
# Hutchinson and Mosier
HM.res <- HM.flux(gas.meas = gas.meas, time.meas = data_split[[f]]$Etime,
flux.term = flux.term, Ci = Ci, C0 = C0, k = kappa.min,
k.max = kappa.max, Ci.lim = Ci.limits, C0.lim = C0.limits)
HM.res
## Set working directory ####
## Rdata files are saved in the working directory
setwd("I:/SCIENCE-IGN-ALL-Climaite-metdata/GoFluxYourself (Standardized R scripts)")
## Create results folder
results_folder  <- paste(getwd(), "flux results", sep = "/")
if(dir.exists(results_folder) == FALSE){dir.create(results_folder)}
# Load required packages
source("000 required packages.R")
## Load gas measurements ####
## (output from script 002 Manual ID)
gas_data <- list.files(path = paste(getwd(), "Rdata", sep = "/"),
pattern = "manID.RData", full.names = TRUE) %>%
.[grep("LGR", .)] %>% map_df(~ get(load(file = .x))) %>%
drop_na(flag)
