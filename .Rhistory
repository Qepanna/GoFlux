}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
load("data/example_LI8200_imp.RData")
test <- example_LI8200_imp %>% rename("UniqueID" = chamID) %>%
filter(UniqueID == "732a_B_N_1") %>% filter(flag == 1)
gas.meas <- Reduce("c", test[, "H2O_ppm"])
time.meas <- Reduce("c", test[, "Etime"])
flux.term <- flux.term(first(test$Vcham)/100, first(test$Pcham), first(test$Area),
first(test$Tcham), first(test$H2O_ppm)/(1000*1000))
Ci = 20000
C0 = 10000
k = 0.005
prec = 3.5
f.min = MDF(prec, (max(time.meas)+1), length(time.meas), flux.term)
LM.flux <- LM.flux(gas.meas, time.meas, flux.term)[, "LM.flux"]
k.max <- k.max(f.min, LM.flux, (max(time.meas)+1))
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=k)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci*0.5, C0=C0*0.5, k=k),
upper = c(Ci=Ci*2, C0=C0*2, k=k.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!(class(HM) =="try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2, RMSE and nRMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM)) #* flux.term ???
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux, HM.se,
HM.se.rel, HM.R2, HM.RMSE)
}
HM_results
# EXAMPLE
library(dplyr)
library(minpack.lm)
library(msm)
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
load("data/example_LI8200_imp.RData")
test <- example_LI8200_imp %>% rename("UniqueID" = chamID) %>%
filter(UniqueID == "732a_B_N_1") %>% filter(flag == 1)
gas.meas <- Reduce("c", test[, "H2O_ppm"])
time.meas <- Reduce("c", test[, "Etime"])
flux.term <- flux.term(first(test$Vcham)/100, first(test$Pcham), first(test$Area),
first(test$Tcham), first(test$H2O_ppm)/(1000*1000))
Ci = 20000
C0 = 10000
k = 0.005
prec = 3.5
f.min = MDF(prec, (max(time.meas)+1), length(time.meas), flux.term)
LM.flux <- LM.flux(gas.meas, time.meas, flux.term)[, "LM.flux"]
k.max <- k.max(f.min, LM.flux, (max(time.meas)+1))
k.max <- 0.01
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=k)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci*0.5, C0=C0*0.5, k=k),
upper = c(Ci=Ci*2, C0=C0*2, k=k.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!(class(HM) =="try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2, RMSE and nRMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM)) #* flux.term ???
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux, HM.se,
HM.se.rel, HM.R2, HM.RMSE)
}
HM_results
# EXAMPLE
library(dplyr)
library(minpack.lm)
library(msm)
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
load("data/example_LI8200_imp.RData")
test <- example_LI8200_imp %>% rename("UniqueID" = chamID) %>%
filter(UniqueID == "732a_B_N_1") %>% filter(flag == 1)
gas.meas <- Reduce("c", test[, "H2O_ppm"])
time.meas <- Reduce("c", test[, "Etime"])
flux.term <- flux.term(first(test$Vcham)/100, first(test$Pcham), first(test$Area),
first(test$Tcham), first(test$H2O_ppm)/(1000*1000))
Ci = 20000
C0 = 10000
k = 0.005
prec = 3.5
f.min = MDF(prec, (max(time.meas)+1), length(time.meas), flux.term)
LM.flux <- LM.flux(gas.meas, time.meas, flux.term)[, "LM.flux"]
k.max <- k.max(f.min, LM.flux, (max(time.meas)+1))
k.ratio = 0.5
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=k)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci*0.5, C0=C0*0.5, k=k),
upper = c(Ci=Ci*2, C0=C0*2, k=k.max*k.ratio),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
# If no error encountered,
if(!(class(HM) =="try-error")){
# then extract values from the HM model
HM.Ci <- coef(summary(HM))[1,1]
HM.C0 <- coef(summary(HM))[2,1]
HM.k <- coef(summary(HM))[3,1]
# Calculate the flux from slope at t = 0
HM.slope <- (HM.Ci - HM.C0)*HM.k
# Multiply the slope of the model by the flux term calculated previously.
HM.flux <- HM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ (x1 - x2) * x3 * %f", flux.term)
HM.se <- deltamethod(as.formula(form), coef(HM), vcov(HM))
# Indices of the model fit
# Relative flux standard error, R2, RMSE and nRMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM)) #* flux.term ???
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux, HM.se,
HM.se.rel, HM.R2, HM.RMSE)
}
HM_results
k.max
#'                sequence a repetition (1,1,2,2,3,3). Default is rep.seq = F.
#'
#' @return a numerical sequence
#'
#' @examples
#' seq.rep(from = 1, by = 2, n.rep = 3, length.seq = 6)
#' seq.rep(from = 1, by = 2, n.rep = 3, length.seq = 6, rep.seq = TRUE)
#'
#' @export
#'
seq.rep <- function(from, by, n.rep, length.seq, rep.seq = F) {
if (rep.seq == F) {
sequence <- seq(from = from, by = by, length.out = length.seq)
out.ls <- list()
for (i in 1:length(sequence)) {
out.ls[[i]] <- rep(sequence[i], n.rep) }
unlist(out.ls)
} else {
repetition <- rep(from, n.rep)
out.ls <- list()
for (i in 1:length(repetition)) {
out.ls[[i]] <- seq(from = repetition[i], by = by, length.out = length.seq) }
unlist(out.ls)
}
}
seq.rep(from = 1, by = 2, n.rep = 3, length.seq = 6)
seq.rep(from = 1, by = 2, n.rep = 3, length.seq = 6, rep.seq = TRUE)
# EXAMPLE HM.flux
library(dplyr)
library(minpack.lm)
library(msm)
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
load("data/example_LI8200_imp.RData")
test <- example_LI8200_imp %>% rename("UniqueID" = chamID) %>%
filter(UniqueID == "732a_B_N_1") %>% filter(flag == 1)
gas.meas <- Reduce("c", test[, "H2O_ppm"])
time.meas <- Reduce("c", test[, "Etime"])
flux.term <- flux.term(first(test$Vcham)/100, first(test$Pcham), first(test$Area),
first(test$Tcham), first(test$H2O_ppm)/(1000*1000))
Ci = 20000
C0 = 10000
k = 0.005
prec = 3.5
f.min = MDF(prec, (max(time.meas)+1), length(time.meas), flux.term)
LM.flux <- LM.flux(gas.meas, time.meas, flux.term)[, "LM.flux"]
k.max <- k.max(f.min, LM.flux, (max(time.meas)+1))
k.ratio = 0.5
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=k)
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci*0.5, C0=C0*0.5, k=k),
upper = c(Ci=Ci*2, C0=C0*2, k=k.max*k.ratio),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
class(HM)
inherits(HM, "try-error")
## Set working directory ####
## Rdata files are saved in the working directory
setwd("I:/SCIENCE-IGN-ALL-Climaite-metdata/GoFluxYourself (Standardized R scripts)")
# Load package GoFluxYourself from GitHub (require devtools)
if (!require("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("Qepanna/GoFluxYourself")
# If you get this warning: "package ‘GoFluxYourself’ is in use and will not be
# installed", then run the following line before installing the pacakge:
# detach("package:GoFluxYourself", unload = TRUE)
library(GoFluxYourself)
## Folder structure
function_path <- paste(getwd(), "functions", sep = "/")
Rdata_path <- paste(getwd(), "Rdata", sep = "/")
aux_file <- paste(getwd(), "test files/LGR/example_aux_LGR.xlsx", sep = "/")
## Create output file: add "manID" to file name
file.name <- "LGR_example_2022-10"
outputfile <- paste(Rdata_path, "/", file.name, "_manID.Rdata", sep = "")
## Load auxiliary data ####
## (requires start.time and UniqueID)
## start.time must contain DATE. Otherwise, DATE must also be provided.
auxfile <- read_excel(aux_file) %>%
mutate(DATE = as.character(DATE)) %>%
mutate(start.time = paste(substring(as.character(start.time), 12, 19)),
start.time = as.POSIXct(paste(DATE, start.time), tz = "UTC"),
start.time = start.time + delay_LGR) # Remove delay if you don't have one
## Load auxiliary data ####
## (requires start.time and UniqueID)
## start.time must contain DATE. Otherwise, DATE must also be provided.
library(readxl)
auxfile <- read_excel(aux_file) %>%
mutate(DATE = as.character(DATE)) %>%
mutate(start.time = paste(substring(as.character(start.time), 12, 19)),
start.time = as.POSIXct(paste(DATE, start.time), tz = "UTC"),
start.time = start.time + delay_LGR) # Remove delay if you don't have one
## Load gas measurements ####
inputfile <- list.files(path = Rdata_path, pattern = "imp.Rdata", full.names = TRUE) %>%
.[grep("LGR", .)] %>% map_df(~ get(load(file = .x))) %>%
# Convert milliseconds to seconds for compatibility with other instruments
mutate(POSIX.time = as.POSIXct(round(POSIX.time, "secs")))
## Load gas measurements ####
library(purrr)
inputfile <- list.files(path = Rdata_path, pattern = "imp.Rdata", full.names = TRUE) %>%
.[grep("LGR", .)] %>% map_df(~ get(load(file = .x))) %>%
# Convert milliseconds to seconds for compatibility with other instruments
mutate(POSIX.time = as.POSIXct(round(POSIX.time, "secs")))
# Define measurements' window:
flux.unique <- obs.win(inputfile = inputfile, auxfile = auxfile,
gastype = "CO2dry_ppm", obs.length = 180)
# If you get this warning: "package ‘GoFluxYourself’ is in use and will not be
# installed", then run the following line before installing the pacakge:
# detach("package:GoFluxYourself", unload = TRUE)
library(GoFluxYourself)
# Define measurements' window:
flux.unique <- obs.win(inputfile = inputfile, auxfile = auxfile,
gastype = "CO2dry_ppm", obs.length = 180)
GoFluxYourself::obs.win()
# Load package GoFluxYourself from GitHub (require devtools)
if (!require("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("Qepanna/GoFluxYourself")
setwd("I:/SCIENCE-IGN-ALL-Climaite-metdata/GoFluxYourself (Standardized R scripts)")
# Load package GoFluxYourself from GitHub (require devtools)
if (!require("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("Qepanna/GoFluxYourself")
# If you get this warning: "package ‘GoFluxYourself’ is in use and will not be
# installed", then run the following line before installing the pacakge:
# detach("package:GoFluxYourself", unload = TRUE)
library(GoFluxYourself)
## Folder structure
function_path <- paste(getwd(), "functions", sep = "/")
Rdata_path <- paste(getwd(), "Rdata", sep = "/")
aux_file <- paste(getwd(), "test files/LGR/example_aux_LGR.xlsx", sep = "/")
## Create output file: add "manID" to file name
file.name <- "LGR_example_2022-10"
outputfile <- paste(Rdata_path, "/", file.name, "_manID.Rdata", sep = "")
## Load auxiliary data ####
## (requires start.time and UniqueID)
## start.time must contain DATE. Otherwise, DATE must also be provided.
require(readxl)
auxfile <- read_excel(aux_file) %>%
mutate(DATE = as.character(DATE)) %>%
mutate(start.time = paste(substring(as.character(start.time), 12, 19)),
start.time = as.POSIXct(paste(DATE, start.time), tz = "UTC"),
start.time = start.time + delay_LGR) # Remove delay if you don't have one
# Other required packages
require(dplyr)
require(readxl)
require(purrr)
## Folder structure
function_path <- paste(getwd(), "functions", sep = "/")
Rdata_path <- paste(getwd(), "Rdata", sep = "/")
aux_file <- paste(getwd(), "test files/LGR/example_aux_LGR.xlsx", sep = "/")
## Create output file: add "manID" to file name
file.name <- "LGR_example_2022-10"
outputfile <- paste(Rdata_path, "/", file.name, "_manID.Rdata", sep = "")
## Load auxiliary data ####
## (requires start.time and UniqueID)
## start.time must contain DATE. Otherwise, DATE must also be provided.
auxfile <- read_excel(aux_file) %>%
mutate(DATE = as.character(DATE)) %>%
mutate(start.time = paste(substring(as.character(start.time), 12, 19)),
start.time = as.POSIXct(paste(DATE, start.time), tz = "UTC"),
start.time = start.time + delay_LGR) # Remove delay if you don't have one
## Load gas measurements ####
inputfile <- list.files(path = Rdata_path, pattern = "imp.Rdata", full.names = TRUE) %>%
.[grep("LGR", .)] %>% map_df(~ get(load(file = .x))) %>%
# Convert milliseconds to seconds for compatibility with other instruments
mutate(POSIX.time = as.POSIXct(round(POSIX.time, "secs")))
# Define measurements' window:
flux.unique <- obs.win(inputfile = inputfile, auxfile = auxfile,
gastype = "CO2dry_ppm", obs.length = 180)
# Here is one short loop as an example
flux.corr.example <- lapply(seq(1,3), click.peak.loop)
# Here is one short loop as an example
flux.corr.example <- lapply(seq(1,3), click.peak.loop, flux.unique)
data.manID <- map_df(flux.corr.example,  ~as.data.frame(.x))
# Add missing auxiliary data. Final output requires:
# UniqueID, Etime, flag, Vtot (or Vcham and offset),
# Area, Pcham, Tcham, H2O_ppm and other gases
data.manID <- data.manID %>% right_join(
auxfile %>% select(UniqueID, Area, Vtot, Tcham, Pcham), by = "UniqueID")
# Save output file
save(data.manID, file = outputfile)
