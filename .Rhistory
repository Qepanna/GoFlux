# Indices of the model fit
# Relative flux standard error, R2 and RMSE
HM.se.rel <- (HM.se / HM.flux) * 100
HM.R2 <- as.numeric(summary(lm(fitted(HM) ~ gas.meas))[9])[1]
HM.RMSE <- RMSE(gas.meas, fitted(HM))
# Store results in new data table
HM_results <- cbind.data.frame(HM.Ci, HM.C0, HM.k, HM.slope, HM.flux,
HM.se, HM.se.rel, HM.R2, HM.RMSE)
} else {
HM_results <- cbind.data.frame(HM.Ci = NA, HM.C0 = NA, HM.k = NA,
HM.slope = NA, HM.flux = NA, HM.se = NA,
HM.se.rel = NA, HM.R2 = NA, HM.RMSE = NA)
}
}
CO2_results <- goFlux(gas_data, "CO2dry_ppm")
View(CO2_results)
load("I:/SCIENCE-IGN-ALL-Climaite-metdata/GoFluxYourself (Standardized R scripts)/Rdata/LGR_example_2022-10_manID.RData")
# TEST
library(dplyr)
library(tidyr)
library(msm)
library(minpack.lm)
library(purrr)
dataframe <- data.manID
gastype <- "CH4dry_ppb"
H2O_col = "H2O_ppm"
prec = NULL
Area = NULL
offset = NULL
Vtot = NULL
Vcham = NULL
Pcham = NULL
Tcham = NULL
k.ratio = 1
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
Ci.lim <- c(-Inf, 0)
C0.lim <- c(-Inf, 0)
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
Ci.lim <- c(0, Inf)
C0.lim <- c(0, Inf)
}
k.ratio = 1
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
Ci.lim <- c(-Inf, 0)
C0.lim <- c(-Inf, 0)
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
Ci.lim <- c(0, Inf)
C0.lim <- c(0, Inf)
}
#' @param V_L numerical; total volume inside the chamber, tubes, instruments, etc. (L)
#' @param P_kPa numerical; atmospheric pressure (kPa)
#' @param A_cm2 numerical; area of the soil surface inside the chamber (cm2)
#' @param T_C numerical; air temperature before chamber closure (Celsius)
#' @param H2O_mol numerical; water vapor concentration in the air before chamber closure (mol/mol)
#'
#' @return a numerical value
#'
#' @keywords internal
#'
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
# TEST
library(dplyr)
library(tidyr)
library(msm)
library(minpack.lm)
library(purrr)
dataframe <- data.manID
gastype <- "CH4dry_ppb"
H2O_col = "H2O_ppm"
prec = NULL
Area = NULL
offset = NULL
Vtot = NULL
Vcham = NULL
Pcham = NULL
Tcham = NULL
k.ratio = 1
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
g.factor <- function(HM.flux, LM.flux){
HM.flux/LM.flux
}
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
# Assign NULL to variables without binding
H2O_ppm <- H2O_mol <- Etime <- flag <- NULL
# Modify global options for warning: break for-loop after warning message
options(warn = 2)
# Use provided values for Area, offset, Vcham, Vtot, Pcham and Tcham
# if they are missing from dataframe
if (!is.null(Area)) {
dataframe <- dataframe %>% mutate(Area = Area)
}
if (!is.null(offset)) {
dataframe <- dataframe %>% mutate(offset = offset)
}
if (!is.null(Vcham)) {
dataframe <- dataframe %>% mutate(Vcham = Vcham)
}
if (!is.null(Vtot)) {
dataframe <- dataframe %>% mutate(Vtot = Vtot)
}
if (!is.null(Pcham)) {
dataframe <- dataframe %>% mutate(Pcham = Pcham)
}
if ((!is.null(Tcham))) {
dataframe <- dataframe %>% mutate(Tcham = Tcham)
}
# Calculate Vtot if absent from dataframe
if (!any(grepl("Vtot", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Vtot = Vcham + (Area * offset))
}
# Use normal atmospheric pressure and ambient temperature
# if Pcham and Tcham are missing from dataframe
if (!any(grepl("Pcham", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Pcham = 101.325)
}
if (!any(grepl("Tcham", names(dataframe)))) {
dataframe <- dataframe %>% mutate(Tcham = 15)
}
# Clean and subset data (per gastype)
if (gastype != "H2O_ppm") {
data_split <- dataframe %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Use mutate() to convert H2O_ppm into H2O_mol
mutate(H2O_mol = H2O_ppm / (1000*1000)) %>%
select(UniqueID, H2O_mol, Etime, Vtot, Pcham, Area, Tcham,
flag, matches(gastype)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
} else
if (gastype == "H2O_ppm") {
data_split <- dataframe %>%
select(UniqueID, Etime, Vtot, Pcham, Area, Tcham,
flag, all_of(H2O_col)) %>%
# Rename H2O_col
rename(H2O_ppm = all_of(H2O_col)) %>%
# Remove bad measurements (flag == 0)
filter(flag == 1) %>%
# Use drop_na() to remove NAs
drop_na(matches(gastype)) %>% group_by(UniqueID) %>%
# Interpolate missing values for chamber pressure and temperature
fill(Pcham, Tcham, .direction = "up") %>%
# Remove duplicates of Etime
ungroup() %>% distinct(UniqueID, Etime, .keep_all = TRUE) %>%
# Split dataset by UniqueID
group_split(UniqueID) %>% as.list()
}
# Instrument precision (by gastype)
# If prec = NULL, the default parameters are set to the LI-7810 for CH4 and CO2,
# or the LI-7820 for N2O. Both instruments have the same precision for H2O.
if (is.null(prec)) {
prec <- ifelse(gastype == "CO2dry_ppm", 3.5,
ifelse(gastype == "CH4dry_ppb", 0.6,
ifelse(gastype == "N2Odry_ppb", 0.4,
ifelse(gastype == "H2O_ppm", 45, NA))))
} else { prec = prec }
# Calculate auxiliary variables: flux term and minimal detectable flux
for (f in 1:length(data_split)) {
H2O_flux.term <- ifelse(gastype == "H2O_ppm", 0, first(data_split[[f]]$H2O_mol))
data_split[[f]] <- data_split[[f]] %>%
mutate(flux.term = flux.term(first(Vtot), first(Pcham), first(Area),
first(Tcham), H2O_flux.term),
f.min = MDF(prec, (max(Etime)+1), n(), flux.term))
}
# Create an empty list to store results
flux.res.ls <- list()
f = 1
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
# Calculate kappa thresholds based on MDF, LM.flux and Etime
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
kappa.max
k.max = kappa.max
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
Ci.lim <- c(-Inf, 0)
C0.lim <- c(-Inf, 0)
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
Ci.lim <- c(0, Inf)
C0.lim <- c(0, Inf)
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
nlsLM(HMmod,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
# Run the model using the nlsLM function from the minpack.lm package
HM <- try(nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0)))
c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min)
Ci
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
Ci.lim <- c(Inf, 0)
C0.lim <- c(Inf, 0)
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
Ci.lim <- c(0, Inf)
C0.lim <- c(0, Inf)
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min),
upper = c(Ci=Ci.lim[2], C0=C0.lim[2], k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
c(Ci=Ci.lim[1], C0=C0.lim[1], k=kappa.min)
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
start
kappa.min
kappa.max
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.max),
upper = c(Ci=Inf, C0=Inf, k=kappa.min),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
Ci+(C0-Ci)*exp(-k*t)
Ci
# TEST
library(dplyr)
library(tidyr)
library(msm)
library(minpack.lm)
library(purrr)
dataframe <- data.manID
gastype <- "CH4dry_ppb"
H2O_col = "H2O_ppm"
prec = NULL
Area = NULL
offset = NULL
Vtot = NULL
Vcham = NULL
Pcham = NULL
Tcham = NULL
k.ratio = 1
flux.term <- function(V_L, P_kPa, A_cm2, T_C, H2O_mol) {
(V_L * P_kPa * (1 - H2O_mol)) / (8.314 * (A_cm2/10000) * (T_C + 273.15))
}
LM.flux <- function(gas.meas, time.meas, flux.term) {
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# Linear model
LM <- lm(gas.meas ~ time.meas)
# Extract values from the linear fit
LM.intercept <- summary(LM)[[4]][1,1]
LM.slope <- summary(LM)[[4]][2,1]
# Multiply the slope of the model by the flux term. The flux term corrects
# for water vapor at the start of the measurement, as well as total volume,
# pressure, area, and temperature. Unique flux term per measurement.
LM.flux <- LM.slope * flux.term
# Use the delta method to propagate total error to the flux calculation.
form <- sprintf("~ x2 * %f", flux.term)
LM.se <- deltamethod(as.formula(form), coef(LM), vcov(LM))
# Indices of the model fit
# Relative flux standard error, R2, p-value, RMSE and nRMSE
LM.se.rel <- (LM.se / LM.flux) * 100
LM.R2 <- as.numeric(summary(lm(fitted(LM) ~ gas.meas))[9])[1]
LM.p.val <- summary(LM)[[4]][2,4]
LM.RMSE <- RMSE(gas.meas, fitted(LM))
# Store results in new data table
LM_results <- cbind.data.frame(LM.slope, LM.intercept, LM.flux, LM.RMSE,
LM.se, LM.se.rel, LM.R2, LM.p.val)
return(LM_results)
}
k.max <- function(MDF, LM.flux, t) {
LM.flux / (MDF * t)
}
g.factor <- function(HM.flux, LM.flux){
HM.flux/LM.flux
}
MDF <- function(p, t, n, flux.term) {
(p / (t * sqrt(n))) * flux.term
}
# Extract auxiliary variables: flux term, minimal detectable flux and UniqueID
UniqueID <- unique(data_split[[f]]$UniqueID)
flux.term <- first(data_split[[f]]$flux.term)
f.min <- first(data_split[[f]]$f.min)
# Extract gas measurement (by gastype)
gas.meas <- Reduce("c", data_split[[f]][, gastype])
# Linear model
LM.res <- LM.flux(gas.meas = gas.meas,
time.meas = data_split[[f]]$Etime,
flux.term = flux.term)
# Calculate C0 and Ci and their boundaries based on LM.flux
C0.flux <- LM.res$LM.intercept
Ci.flux <- (LM.res$LM.slope * max(data_split[[f]]$Etime)) + C0.flux
C.diff.flux <- abs(Ci.flux-C0.flux)
C0.lim.flux <- c(C0.flux-C.diff.flux*0.2, C0.flux+C.diff.flux*0.2)
Ci.lim.flux <- c(Ci.flux-C.diff.flux*0.2, Ci.flux+C.diff.flux*0.2)
# Calculate C0 and Ci and their boundaries based on raw data
C0.raw <- first(gas.meas)
Ci.raw <- last(gas.meas)
# Chose the right C0 and Ci
Ci <- if_else(between(Ci.raw, Ci.lim.flux[1], Ci.lim.flux[2]), Ci.raw, Ci.flux)
C0 <- if_else(between(C0.raw, C0.lim.flux[1], C0.lim.flux[2]), C0.raw, C0.flux)
# Calculate kappa thresholds based on MDF, LM.flux and Etime
kappa.max <- k.max(f.min, LM.res$LM.flux, (max(data_split[[f]]$Etime)+1))
# Root Mean Squared Error (RMSE)
RMSE <- function(gas.meas, fit.val){
sqrt(sum((na.omit(gas.meas - fit.val))^2) / length(na.omit(gas.meas)))
}
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
# Define the Hutchinson and Mosier model
HMmod <- conc ~ Ci+(C0-Ci)*exp(-k*t)
# Define the initial parameters for the fitting of the model
start <- list(Ci=Ci, C0=C0, k=0)
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
kappa.min
kappa.max
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
k.max = kappa.max
# kappa limits
if (k.max < 0) {
kappa.max <- 0
kappa.min <- k.max*k.ratio
} else {
kappa.max <- k.max*k.ratio
kappa.min <- 0
}
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
kappa.min
kappa.max
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=-Inf),
upper = c(Ci=Inf, C0=Inf, k=kappa.max),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
nlsLM(HMmod, trace = T,
data = cbind.data.frame(conc = gas.meas, t = time.meas),
lower = c(Ci=0, C0=0, k=kappa.min),
upper = c(Ci=Inf, C0=Inf, k=Inf),
start = start,
na.action = na.exclude,
control = nls.lm.control(
ftol = sqrt(.Machine$double.eps),
ptol = sqrt(.Machine$double.eps),
gtol = 0, diag = list(), epsfcn = 0, factor = 100,
maxfev = integer(), maxiter = 1000, nprint = 0))
